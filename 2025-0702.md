#### 高通-生成签名key使用的指令
``` bash
openssl genrsa -out qpsa_rootca.key 2048

openssl req -new -sha256 -key qpsa_rootca.key -x509 -out rootca_pem.crt \
-subj "/C=US/ST=California/L=San Diego/OU=General Use Test Key (for testing 13 only)/OU=CDMA Technologies/O=QUALCOMM/CN=QCT Root CA 1" \
-days 7300 -set_serial 1 -config opensslroot.cfg \
-sigopt rsa_padding_mode:pss -sigopt rsa_pss_saltlen:-1 -sigopt digest:sha256

openssl x509 -in rootca_pem.crt -inform PEM -out qpsa_rootca.cer -outform DER

openssl x509 -text -inform DER -in qpsa_rootca.cer



openssl genrsa -out qpsa_attestca.key 2048

openssl req -new -key qpsa_attestca.key -out attestca.csr \
-subj "/C=US/ST=CA/L=San Diego/OU=CDMA Technologies/O=QUALCOMM/CN=QUALCOMM Attestation CA" \
-config opensslroot.cfg

openssl x509 -req -in attestca.csr -CA rootca_pem.crt -CAkey qpsa_rootca.key \
-out attestca_pem.crt -set_serial 5 -days 7300 -extfile v3.ext \
-sigopt rsa_padding_mode:pss -sigopt rsa_pss_saltlen:-1 -sigopt digest:sha256

openssl x509 -inform PEM -in attestca_pem.crt -outform DER -out qpsa_attestca.cer


openssl dgst -sha384 qpsa_rootca.cer > sha384rootcert.txt
```
#### 保留原路径复制文件的shell函数
``` shell
cp_keep_path() {
    local src=$1
    if [ -f "$src" ]; then
        # 单个文件复制
        local rel_path=$(realpath --relative-to="$PROJECT_ROOTDIR" "$src")
        local dst="${OUT_PKG_DIR}/${rel_path}"
        mkdir -p "$(dirname "$dst")"
        cp -f "$src" "$dst"
        echo "Copied file: $src -> $dst"
    elif [ -d "$src" ]; then
        # 递归复制目录中的所有文件
        find "$src" -type f | while read -r file; do
            local rel_path=$(realpath --relative-to="$PROJECT_ROOTDIR" "$file")
            local dst="${OUT_PKG_DIR}/${rel_path}"
            mkdir -p "$(dirname "$dst")"
            cp -f "$file" "$dst"
            echo "Copied file: $file -> $dst"
        done
    else
        echo "Warning: File or directory not found - $src"
    fi
}
```
#### 单独构建NON_HLOS.bin
``` bash
python build.py --imf 2>&1|tee generate_non_hlos.log
#patch project/nonhlos/Divar.LA.3.0.1/common/build
```
>**NOTE1**: 高通平台需要签名的镜像，给一些设置了分区，签名后可以直接替换刷机，但固件(firmware)、ta和mondel这些没有分区，分别需要打包到vendor和NON_HLOS镜像，固件签名后可以提到代码中重新编译vendor部分，NON_HLOS.bin可以把签名后的镜像覆盖到源路径，然后单独构建
>**NOTE2**：高通sec-boot v2往后需要配置 oem-id，且这个id需要公司向高通申请，没有正确配置这个id值，熔丝后会不开机也不吐log

#### selinux作用域
vendor和system部分的策略文件 有作用域的区分
test1：在vendor的策略文件里添加public参数验证
test2：在system部分代码添加 vendor 部分的权限

``` te
type fm_lna_device, dev_type, public;
```
#### DTS有效电平
``` shell
	fm_lna: fm_lna {
		status = "okay";
		compatible = "tinno,fm_lna";
		lna-en-gpios = <&tlmm 65 GPIO_ACTIVE_HIGH>;
	};
```
GPIO_ACTIVE_HIGH：对应高电平有效，代码中 `gpiod_set_value(fm_lna_pdata->lna_gpiod, 1);`使能电压
GPIO_ACTIVE_LOW：对应低电平有效，代码中`gpiod_set_value(fm_lna_pdata->lna_gpiod, 1);`使能电压

